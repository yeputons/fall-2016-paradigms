План:

Mutex'ы надо применять с умом: пример с дописыванием двух элементов в конец безопасного списка.
Дубовый способ "--- берём на все операции, отпускаем в конце. В плюсах есть RAII, в Java "--- synchronized.
показать read-write locks.

Показать, что оптимизатор тоже веселится (хотя race condition как бы нет).
Показать volatile. Он только говорит <<всегда пиши в память>>.
Сказать, что его не надо использовать из-за reordering на уровне компилятора, процессора и его кэшей (+пример кода, без упражнения). Упомянуть барьеры памяти и разные модели памяти (в Java - happens-before).
Поэтому всегда используем mutex'ы - в них уже всё это реализовано (и проблема с reordering, и happens-before, и всё остальное).

Потоки не всегда независимы, иногда хотят синхронизироваться/обмениваться сообщениями, рассказать про Producer/Consumer.
Задача: один поток иногда говорит "я прислал тебе сообщение", а второй это читает.
Дубовый способ: как бы spin lock, когда один ждёт другого. Потребляет процессор почём зря.
Первый подход: события. Сначала события без состояния, просто будильник. Тогда проблема с lost wakeup race condition.
Второй подход: добавим состояние (событие просигналено/не просигналено) - получим Windows Events.
Третий подход: conditional variables без внутреннего состояния. Используется в pthreads, Java и ещё много где.
Атомарно начинает ждать события и отпускает мьюьтекс.
Пример.
Пример без condvar с lost wakeup race condition?
Упражнение: выразить событие через conditional variable.

Проблемы всегда возникают, когда есть общие ресурсы, например, память или файлы.
Общих ресурсов нет - нет проблем. Поэтому стараются по минимуму использовать общие ресурсы.

Как обычно применяется: producer/consumer (классика), fork/join (наворот над классикой), actors (это пример "без общих ресурсов").

Пример fork/join: merge sort (псевдокод).

Домашнее задание: Thread Pool.
Это чтобы не создавать на каждый чих поток ОС, и сильно ограничить число потоков (и не грузить процессор так сильно).
Сколько угодно producer'ов, фиксированное число consumer'ов. Есть в Java (там вообще всё есть).
Задача - это функция + аргумент void*.
Можно: создать пул, удалить пул, кинуть задачу в пул, подождать выполнения задачи (либо ноль, либо один, либо много раз - пофиг).
Задачи создаёт пользователь.
