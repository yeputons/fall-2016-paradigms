from random import *
names="""
Mutex
Conditional variable
Race condition
Deadlock
Livelock
Joinable-поток
Detached-поток
Атомарное изменение
Spurious wakeup
Торт
Редиска
""".split("\n")[1:-1]
defs="""
Примитив синхронизации, позволяющий потокам атомарно захватывать и освобождать его; его может захватить не более одного потока
Примитив синхронизации, используемый для ожидания событий
Ситуация, при которой результат работы программы зависит от того, в каком порядке выполнялись инструкции в потоках
Ситуация, при которой несколько потоков уснули и ждут друг друга, гарантируется, что они не смогут проснуться от внешних событий
Ситуация, при которой несколько потоков гарантированно не смогут совершать полезную работу в будущем, но, тем не менее, не спят
Поток, у которого после завершения необходимо получить возвращённое значение и освободить ресурсы
Поток, у которого невозможно получить возвращённое значение; его ресурсы освобождает ОС
Изменение, которое \"видно\" другим потокам либо полностью, либо никак, но не частично
Ситуация, при которой поток разбудили при отсутствии события, которого он ждал
Кондитерское изделие
Человек, использующий для синхронизации потоков sleep() и while вместо примитивов синхронизации
""".split("\n")[1:-1]
assert len(names) == len(defs) == 11

defs=list(enumerate(defs))
shuffle(defs)
ans=[0] * len(defs)
for cid, (oid, v) in enumerate(defs):
  ans[oid] = cid + 1
print("\n".join(names))
print()
print("\n".join(map(lambda x: x[1], defs)))
print(",".join(map(str, ans)))
