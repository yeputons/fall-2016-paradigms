\section{Вещественные числа}
\subsection{Идеи}

\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}
	Зачем нужны вещественные числа в компьютерах?
	Почему нельзя обойтись целыми?

	\pause
	\begin{itemize}
		\item Работа с дробями и деление.
		\item Денежные единицы: копейки удобно считать сотыми частями рубля.
		\item Физические (и военные) вычисления: тригонометрия, расстояния, геокоординаты.
	\end{itemize}
\end{frame}

\begin{frame}{С фиксированной запятой}
	Пример: рубли.
	
	После запятой всегда ровно два знака: $230.40$.

	По сути те же целые числа, только надо помнить, где стоит запятая, и перемножаются чуть по-другому (со сдвигом запятой и, соответственно, обрезанием знаков).

	Плюсы: абсолютная точность (кроме умножения и деления, иногда), простота, предсказуемость, и очевидность операций и границ типа (как для целого, только минус два десятичных знака).

	Есть в некоторых базах данных, используются как раз для хранения количества денег.
\end{frame}

\begin{frame}{Минусы}
	Надо заранее знать, сколько знаков потребуется.
	
	Если может требоваться разное число знаков в разных местах "--- надо брать разные типы данных и конвертировать.
	Соответственно, нужен разный код, если вычисления с <<большими>> числами и если с <<маленькими>>.

	Не реализовать аппаратно, потому что неясно, сколько знаков отбрасывать при умножении.
\end{frame}

\begin{frame}{С плавающей запятой}
	Обобщение фиксированной запятой.
	Храним число и сколько у нас знаков идёт после запятой, а сколько "--- до.

	Умножение и деление остались примерно такими же по сложности, а вот сложение и вычитание усложнились (надо сравнивать порядок чисел).

	Теперь можно делать вычисления числами любого порядка, и будем знать порядок ответа и первые сколько-то цифр.

	Одинаково хорошо работает и с маленькими, и с большими числами.
	Относительная погрешность вычислений одинакова.
\end{frame}

\subsection{Детали}
\begin{frame}{Трудности с десятичной системой}
	Пусть храним числа так:
	\begin{gather*}
		x = a \cdot 10^{b} \\
		-32768 \le a, b \le 32767 \\
	\end{gather*}
	Тут $a$ "--- \textit{мантисса}, $b$ "--- \textit{экспонента}.

	Например:
	\begin{align*}
		12.3 &= 123 \cdot 10^{-1} \\
		321000 &= 321 \cdot 10^3 \\
		12.3 \cdot 321000 &= 123 \cdot 10^{-1} \cdot 321 \cdot 10^3 = (123 \cdot 321) \cdot 10^{-1+3} = 39483 \cdot 10^2 \\
		12.3 + 321000 &= 123 \cdot 10^{-1} + 321 \cdot 10^3 = \pause (123 + \underbrace{3210000}_{>32767}) \cdot 10^{-1}
	\end{align*}
	Получаем, что при сложении у нас легко может произойти переполнение типа.
	Можно пытаться оставлять только самые значащие цифры.
	Но в общем случае надо домножать на большую степень десятки, как это делать без очень больших чисел и без домножения на десятку каждый раз "--- неясно.
	Храним-то всё в двоичной системе, а там от умножения на десять все знаки меняются.
\end{frame}

\begin{frame}{Решение проблемы}
	Храним числа так:
	\begin{gather*}
		x = a \cdot 2^b \\
		-32768 \le a, b \le 32767 \\
	\end{gather*}

	Теперь стало легко и складывать, и перемножать, так как при домножении на двойку легко понять, сколько цифр не нужны.

	Появились проблемы с тем, что нет чёткого соответствия между десятичными знаками после запятой и двоичными.

	Отсюда трудности с точным хранением:
	\begin{align*}
		0.75_{10} &= {0.11}_{2} \\
		7 \cdot 10^{-1} + 5 \cdot 10^{-2} = 2^{-1} + 2^{-2} \\
		0.1_{10} &= {0.000110011001100110011001101\dots}_{2} \\
		10^{-1} &= 2^{-4} + 2^{-5} + 2^{-7} + 2{^-8} + \dots \\
	\end{align*}
	Введите в Python \t{"\{:.1000\}".format(0.1)}.
	А потом домножьте \t{0.1} на двойку 55 раз и выведите результат.

	Зато это стало вообще возможно реализовать.
\end{frame}
