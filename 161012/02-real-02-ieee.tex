\subsection{IEEE 754}
\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}{Что такое IEEE 754}
	\begin{itemize}
		\item
			IEEE 754 "--- это стандарт хранения и обработки вещественных чисел с плавающей запятой, который используется почти везде.
		\item
			Но не вообще везде.
		\item
			Определяет несколько типов данных с разными размерами мантисс и экспонент: single precision, double precision, и ещё несколько.
		\item
			Достаточно разумно определяет операции для всех аргументов и решает некоторые проблемы.
		\item
			Из-за этого сложнее, чем идея с предыдущих слайдов.
		\item
			Есть $\pm \infty$, есть \t{NaN} (Not a Number, получается при делении нуля на ноль).
		\item
			В Python используется double-precision (тип \t{float}).
		\item
			В C++/Java есть как single-precision (\t{float}), так и double-precision (\t{double}).
	\end{itemize}
\end{frame}

\begin{frame}{Формат single-precision}
	Основная масса "--- \textit{нормализованные числа}:
	\begin{center}
		\begin{tabular}{c|c|c}
			\multicolumn{3}{c}{Биты} \\
			31 & 30-23 & 22-0 \\\hline
			знак ($s$) & экспонента ($e$) & мантисса ($m$) \\
		\end{tabular}
	\end{center}
	\begin{enumerate}
		\item
			Если $s=0$, то число положительное, иначе отрицательное.
		\item
			Предполагается, что экспонента подобрана так, чтобы перед запятой был ровно один знак "--- единица.
		\item
			Мантисса хранит все знаки \textit{строго после} этой единицы.
		\item
			Итоговая формула (для \textit{нормализованных} чисел):
			\[ x = (-1)^s \cdot 2^{e-127} \cdot (1 + m \cdot 2^{-23}) \]
	\end{enumerate}
\end{frame}

\begin{frame}{Хранение экспоненты}
	Экспонента хранится как беззнаковое число со сдвигом на 127:
	\begin{center}
		\begin{tabular}{r|l}
			Двоичное представление & $e$ \\\hline
			\t{0000 0000} & -127 \\
			\t{0000 0001} & -126 \\
			\vdots & \vdots \\
			\t{0111 1110} & -1 \\
			\t{0111 1111} & 0 \\
			\t{1000 0000} & 1 \\
			\vdots & \vdots \\
			\t{1111 1110} & 127 \\
			\t{1111 1111} & 128 \\
		\end{tabular}
	\end{center}
	Обратите внимание, что отрезок чисел "--- от $-127$ до 128, а не от $-128$ до $127$ (как в дополнительном коде).
\end{frame}

\begin{frame}{Пример}
	\[
		x = -13.75_{10} = \frac{-220}{16} = -1101.110_2
	\]
	Подбираем экспоненту так, чтобы слева получилась ровно одна единица:
	\[
		x = -1.\underbrace{101110_2}_{m'=92_{10}} \cdot 2^3 \quad e=3
	\]
	Так как в $m$ предполагается 23 значащих знака (а у нас в $m'$ только 6), надо дописать \textit{справа} нулей.
	Итого:
	\begin{center}
		\begin{tabular}{c|c|c|c}
			\multicolumn{3}{c}{Биты} \\
			31 & 30-23 & 22-0 \\\hline
			\t{1} & $\underbrace{\t{100~0001~0}}_{e+128}$ & $\underbrace{\t{\textbf{101~110}0~0000~0000~0000~0000}}_{m}$ \\
		\end{tabular}
	\end{center}	
\end{frame}

\begin{frame}{Денормализованные числа}
	Какое наименьшее нормализованное число можно представить в таком формате?
	Очевидно, при минимальной экспоненте (-127) и мантиссе.
	Тогда самые маленькие числа таковы:
	\begin{align*}
		x &= 2^{-127} \cdot 1 \\
		y &= 2^{-127} \cdot (1 + 1 \cdot 2^{-23}) \\
		z &= 2^{-127} \cdot (1 + 2 \cdot 2^{-23}) \\
		& \vdots \\
	\end{align*}
	Посчитаем что-нибудь:
	\begin{align*}
		x + y &= 2^{-127} \cdot (1 + 1 + 1 \cdot 2^{-23}) = \\
		      &= 2^{-127} \cdot (2 + 1 \cdot 2^{-23}) = \\
		      &= 2^{-126} \cdot (1 + 1 \cdot 2^{-24}) \approx \\
		      &\approx 2^{-126} \cdot 1 \\
		y - x &= 2^{-127} \cdot (1 + 1 \cdot 2^{-23} - 1) = \\
		      &= 2^{-127} \cdot 1 \cdot 2^{-23} = 2^{-150}
	\end{align*}
	Округлять к $2^{-127}$ странно (и тогда бы получили, что $x-y=x$, но $x\neq x + y$).
	Округлять к нулю тоже странно: $x \neq y$, но $x - y = 0$.

	Так что вблизи нуля добавили \textit{денормализованные числа}, чтобы повысить точность и избежать таких проблем (ведь компилятор-то хочет оптимизировать).
	Тогда эта проблема исчезает.

	Хотя всё равно можно получить underflow: \t{2 ** (-1074) / 2 * 2}.
\end{frame}

\begin{frame}{Формат}
	Скажем, что если экспонента состоит из нулей, то у нас денормализованное число:
	\begin{center}
		\begin{tabular}{|r|c|c|c|}
			\hline
			Биты & 31 & 30-23 & 22-0 \\\hline
			Тип & знак ($s$) & нули & мантисса $m$ \\\hline
		\end{tabular}
	\end{center}
	Тут мы уже считаем, что мантисса записана целиком, с учётом старшей единицы.
	Формула:
	\[
		x = (-1)^s \cdot 2^{-12\textbf{6}} \cdot m \cdot 2^{-23}
	\]
	Тогда денормализованные числа лежат в диапазоне:
	\[
		2^{-126} \cdot 2^{-23} \le x \le 2^{-126} \cdot (2^{23}-1) \cdot2^{-23}
	\]
	А нормализованные (так как экспонента из нулей, т.е. $-127$, убита):
	\[
		2^{-126} \cdot 1 \le x
	\]
\end{frame}

\begin{frame}
	\begin{center}
		\includegraphics[scale=0.75]{what-are-you-doing.jpg}
	\end{center}
\end{frame}

\begin{frame}{Все особенности IEEE-754}
	Нормализованных чисел с экспонентой $-127$ не существует "--- это будут \textit{денормализованные} числа (см. следующий слайд).
	Есть два нуля "--- по одному с каждым знаком (попробуйте их сравнить в Python, а потом на C++ на них поделить).
	Сделано для некой внутренней консистентности.

	Нормализованных чисел с экспонентой $128$ не существует "--- это будут либо $+\infty$, либо NaN (not a number).
	Если мантисса из нулей "--- то бесконечность (в зависимости от знака), если есть хоть один не-ноль "--- NaN.
	\begin{center}
		\begin{tabular}{|r|c|c|c|c|}
			\hline
			Биты & 31 & 30-23 & 22-0 & Значение \\\hline
			& \t{0} & \t{111 1111 1} & \t{000 0000 0000 0000 0000 0000} & $+\infty $\\\hline
			& \t{1} & \t{111 1111 1} & \t{000 0000 0000 0000 0000 0000} & $-\infty $\\\hline
			& \t{0} & \t{111 1111 1} & \t{000 1000 0110 0000 0000 0000} & \t{NaN} \\\hline
			& \t{0} & \t{000 0000 0} & \t{000 0000 0000 0000 0000 0000} & $+0$ \\\hline
			& \t{0} & \t{000 0000 0} & \t{000 0000 0000 0000 0000 0000} & $-0$ \\\hline
		\end{tabular}
	\end{center}	
\end{frame}
