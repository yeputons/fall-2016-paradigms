Зачем нужны системы контроля версий
===================================

Для себя:

1. Бэкапы рабочих версий кода (как в архив положить).
2. Даже с комментариями, что и зачем было сделано. Чёткое разграничение изменений друг между другом (если делать правильно). Никаких "я ничего не менял(а)".
3. Быстрый/удобный просмотр отличий между версиями (из архива вытаскивать сложно).
4. Частичный откат к старой версии (если не один файл - из архива вытаскивать сложно, а если без архива - то `cp` не поможет).
5. Можно залить на GitHub в свой репозиторий и тогда получаем удалённый бэкап, его ещё и сложно удалить. Удалили папку - а на сервере всё осталось. Локально надо делать копии архивов в папке, отличной от рабочей, и так далее. Ну, как Dropbox, только с доп. функциональностью.
6. Конкретно в Git и некоторых других системах - ветки, когда можно работать над независимыми фичами одновременно, при этом регулярно смотреть, что отличия не слишком разрослись.

Для команд:

1. Один сервер, на котором лежит последняя версия кода. Все бэкапы - в одном месте. Можно настраивать права доступа.
2. Разрешение конфликтов: кто-то поменял один файл, а кто-то - другой (архивы не помогут). А если поменяли один кусок в одном файле, то иногда тоже могут автоматически смотреть.
3. Понятно, кто, когда и зачем менял код (зачем - только если сообщения есть). Можно подойти и спросить "зачем", можно меряться, кто больше.
4. Если разрабатываете приложение (веб или обычное) - в системе контроля версий можно помечать версии как "для релиза" и точно знать, какой код куда ушёл.
5. Можно интегрировать много с чем:
  1. Continuous Integration для автоматического запуска тестов (скорее бонус конкретной системы хранения, но наличие VCS позволяет иметь один "исходник истины").
  2. Code review для перечитывания кода: система показывает разницу, оставляем комментарии, если всё ок - принимаем изменения: https://github.com/pagespeed/ngx_pagespeed/pull/1286 . Прекрасно подходит для open-source. Пример: https://github.com/rust-lang/rust-www/pull/624
  3. Автоматическая сборка "ночных" сборок и выкладывание их на страницу. https://www.mozilla.org/en-US/firefox/channel/desktop/?v=b
  
Краткий обзор систем
====================

Обычно система хранит некоторый набор файлов и изменения между версиями.
Одна сохранённая версия - "коммит" (commit) или "снимок" (snapshot).
Ещё обычно как-то позволяется работать отдельным людям независимо, а потом "склеивать" изменения. Кто-то хуже, кто-то лучше.

Ad-hoc:

1. Архивы.
2. Пересылка файлов по email/ВК.
3. Хранение на общем сетевом (или внешнем) диске. Нет истории.
4. Dropbox и прочие - удобнее, чем предыдущие, но тоже нет истории, diff'ов и всего остального.
5. Google Docs - задолбаться копировать туда/сюда.

Централизованные: SVN, CVS (устарела), Perforce, Microsoft Team Foundation Server (последние две коммерческие).

1. Хранят всю информацию на одном сервере.
2. Можно очень точно управлять тем, кто и куда может что писать.
3. Нет интернета/сервера - нет возможности сохранить свои изменения.
4. Обычно на любой чих надо идти к серверу (посмотреть историю, изменения). Тормозит разработку.
5. Обычно каждый коммит характеризуется числом: 1, 2, 3...

Децентрализованные: Git, Mercurial (open source).

1. Хранят информацию в целом где угодно, есть возможность скачать репозиторий целиком (а другой возможности может и не быть).
2. Любые действия - локально и быстро.
3. Можно выбрать одно место и назвать его "центральный" сервер (вроде GitHub), и "пушить" изменения на него, но на самом деле так можно между любыми репозиториями.
4. Так как нет центральной системы выдачи номеров коммитам, то они нумеруются как-то. Например, случайными хэшами.
5. Можно творить полную жуть с репозиторием.
6. Нет возможности проверить, во сколько именно и кем был сделан коммит - очень много чего держится на доверии. Или на PGP-подписях. Но не время. Пример: http://codeforces.com/blog/entry/8790?locale=ru#comment-145019
7. Можно использовать вообще без сервера, чисто для себя в качестве системы бэкапов.
8. Если GitHub упал - вы всё ещё можете работать. А он падал, как мы сами видели на парах.

Что надо знать для жизни:

0. Полезно как в компаниях при работе, так и в реальной жизни, если вы пишете хоть что-то с временем жизни больше дня.
1. GitHub != Git, так же как gmail != email. GitHub - это лишь инструмент.
2. Самая модная VCS сейчас - Git, децентрализованная, есть очень много хороших инструментов для неё (тот же GitHub), не самая простая в освоении, но мощная.
3. VCS используются вообще везде в компаниях, с ними чувствуешь себя увереннее.
4. VCS позволяют интегрироваться с кучей полезных инструментов.
5. VCS надо использовать "правильно". Разные "правильно" использовать по-разному, но есть некоторые общие требования. Надо изучать книжки или руководства. Нет "единого правильного подхода". В каждой компании может отличаться. Например, некоторые системы (в том числе Git) плохо подходят, чтобы в них хранить хоть что-то, кроме исходного кода в виде текстов (то есть .doc файлы и прочее мимо кассы).
6. Инструменты для VCS тоже надо использовать "правильно". Опять же, отличается в разных системах.
7. Из VCS очень сложно удалить информацию. Из централизованной почти никогда нельзя (если вы не админ), из децентрализованной (вроде Git) можно при помощи пары специальных команд, так что если где-то читаете ответ на вопрос "как что-то удалить" - будьте осторожны. Обычно в VCS информация только добавляется.

Локальная работа с Git
======================
Напоминание: Git != GitHub.
Ставим https://git-scm.com/ и прописываем в PATH.
Источник знаний: книга "Pro Git", бесплатная, open source (https://github.com/progit/progit2).
	PDF на русском: https://cloud.github.com/downloads/GArik/progit/progit.ru.pdf .
	Страница на русском: https://git-scm.com/book/ru/v1
Игрушка с визуализацией: http://learngitbranching.js.org/
Онлайн-игрушка на ветки: https://github.com/git-game/git-game

Цель: научиться работать с Git из командной строки, потому что все руководства обычно про это. Графический интерфейс и интеграция с IDE - уже потом, когда понимаете терминологию и как работать из консоль. Сначала консоль, потом GUI, иначе будет сложно искать вопросы и ответы (графические оболочки очень отличаются, нет сильно популярных, и для них сложнее сформулировать "что именно сделано").

Git всегда хранит полные "снимки" всего дерева. Про другие системы иногда говорят, что они хранят "разницу между двумя снимками".

Делаем коммиты
--------------
1. `git config --global user.name` и ``git config --global user.email` (всё же на доверии, помните? Вот и говорим, как нас зовут).
2. `git config --global core.editor notepad` (или Nano, или Vim)
2. Заводим папку `git-playground` и делаем в ней `git init`.
3. Пишем `list_util.py` (`startsWithOne` именно с таким неверным регистром и неверной обработкой пустого списка) и `test_util.py` (только тест `[1, 2, 3]`).
4. `git status`, смотрим на "Untracked files" - найдены, но не в репозитории. Делаем `git add` (но без теста), теперь staged - готовы к коммиту. Только staged пойдёт в следующий коммит!
5. `git commit`, вводим сообщение. Также можно `git commit -m"foobar"` и `git commit -Ffile.txt`.
6. Делаем `git clone` из другой папки. Упс, забыли файл, надо добавить. Добавляем в старой папке, коммит `--amend`. МЕНЯЕТ ИСТОРИЮ!!1!. Осторожно с ним (см. дальше).
7. Вспоминаем про неверный регистр, правим, уже в новой папке. Смотрим `git diff`. Теперь он modified, но не staged, надо снова `git add`.
8. Посмотрели `git status`, чтобы проверить, что всё ок. И ещё на всякий случай `git diff`, но он не прокатывает, надо `git diff --cached`.
9. `git commit -m"Something"`.
10. Добавляем test_empty, фиксим реализацию, `git add .` (можно добавлять целые папки). `git commit -Fmsg.txt`.
11. Можно посмотреть `git log` и конкретный коммит при помощи `git show` (кстати, хэш можно не полностью набирать, git предупредит, если неоднозначно). Ура, всё как на ладони. Но упс, мы добавили `__pycache__`.
12. Удаляем при помощи `git rm`, намекнуть про `--preserve-local`. Теперь помечен как deleted, это пойдёт в коммит. Но хрень осталась в истории навсегда :( Намекнуть про rebase, сказать, что небезопасно, пока нет ощущения лёгкости.
13. Можно не добавлять `__pycache__` при помощи `.gitignore`. А вот файлик `.gitignore` положить в репозиторий стоит. Он работает на папке и всех подпапках. Обычно туда вносят всякие exe'шники и прочий мусор, чтобы не засорять историю, diff'ы и размер репозитория.
14. Показываем, что `__pycache__` сохранился при помощи `git checkout commit`. Потом переключаемся обратно при помощи `git checkout master` (тут master - не магия, а "ветка").
15. Намекнуть про `git show master~1`

Когда делать коммиты: часто, но лучше, чтобы была рабочая версия. Если она нерабочая - в отдельную ветку (потом увидим) и переносить изменения.

16. Закоммитить хрень.
17. Откатить при помощи `git reset --soft HEAD~1`. `--soft` оставит изменения в staged, `--hard` убьёт их. Осторожно с этой командой - она ПЕРЕПИСЫВАЕТ ИСТОРИЮ!!1!

Намёк: есть команда `git cp`, есть команда `git mv`, но проверяйте, что файл добавлен. А ещё можно просто руками удалить и добавить новую версию. Git заметит, что файл очень похож на старый и скажет, что это на самом деле один и тот же файл.

Заначка
-------
Задача: написать кассовую систему для магазина. Сначала:

1. Считывает команды по одной (пока что без подсказок пользователю):
	1. Добавить в заказ товар с именем и по цене.
	2. Показать стоимость товара.
	3. Закончить заказ (вводится сумма от покупателя, выдаётся сдача).
2. Пишем отдельный класс CashRegister, а в функции main() - отдельный код, который с ним взаимодействует. Зачем? Тесты! Написали себе TODO в файлике. Также написали README.
3. Про тесты пока забыли, закоммитили.
4. Начали добавлять функциональность "товар по цене и в количестве", но посередине вспомнили про тесты, `git stash`, `git stash list`, `git show stash@{0}`. Намекнуть про интерактивный stash (можно спрятать только кусочек и там много возможностей), что прячутся именно отличия (а не файлы целиком), что они представляют собой стэк из нескольких независимых.
5. Написали пару тестов, убрали TODO, закоммитили.
6. `git stash pop`, намекнуть про `git stash apply` и про то, что в некоторых ситуациях (если не получилось идеально применить изменения), то тогда заначка не исчезает.
7. Добавили функциональность.

Ветки
-----
Ветка - это просто ссылка на коммит. http://learngitbranching.js.org/ `level intro2` (показать). Коммит создаётся и ветка перемещается. Если без ветки (detached-head), то нет коммита. HEAD - это альтернативное название текущей ветки. Можно `git show HEAD~1`.

Нам пришло требование: сделайте, чтобы товар можно было пробивать по его штрих-коду, а не названию, а штрих-коды и названия с ценами брались из файла. Это большое изменение, так что делать мы его будем в отдельной ветке.

1. Сделаем новую ветку, переключимся на неё.
2. Сначала добавим словарь из штрих-кодов в названия и цены в программу просто так, в класс `CashRegister` в конструкторе передаётся словарь, а в метод `addItem` передаётся только штрих-код. Закоммитим.
3. Добавим тесты, закоммитим.
4. Теперь переключимся обратно в master и там срочный фикс: добавить подсказки пользователю (что вводить). Обновили README (добавив опечатку), закоммитили. Посмотрели историю при помощи `git log --all --graph --online --decorate`, вау.
5. Переключаемся в add-barcodes и дописываем считывание из файла. Коммитим. Замечаем, что подсказок всё ещё нет.
6. Переключаемся в master, делаем merge, огребаем конфликт в считывании. Ну, он простой, разрешили (показать, какие где файлы, намекнуть про take theirs/take ours). Закоммитили. Намекнуть про `--abort`, и пометки разрешённого файла. А вот в тестах
7. Теперь посмотрим историю: ух ты, два родителя. Можно посмотреть разницу между любыми двумя коммитами (т.е. состояниями репозитория на этот момент) и убедиться, что всё адекватно.

Картинка есть в `level intro3`.

Смысл веток и заначек: можно быстро переключаться между разными версиями. Например, одну - преподавателю на просмотр, а в другой развлекаемся.
Если в одной поразвлекались, то можно `git merge --squash` или даже squash отдельных частей.

Новое требование: баркод теперь хранится по-другому (csv).

8. Переключаемся в add-barcodes, делаем попытку, коммитим, ничего не работает.
9. Переключаемся в master и фиксим опечатку в README.
10. Переключаемся в add-barcodes. `git revert commit-id`. Добавляем `import csv` и `DictReader` https://docs.python.org/3/library/csv.html#csv.DictReader
11. Получили что надо, но засорять историю не хотим. `git merge --squash`. Чисто эстетическое удовольствие и преподавателю/коллегам приятнее, что каждая версия в основной ветке собирается как надо.

Намекнуть про fast-forward, когда будем мёржить удалённые ветки.

Работа с удалёнными репозиториями
=================================

1. `git clone <наш старый репозиторий> <наша новая папка>`.
2. Получили точную копию. В ней можно сделать коммит, но в старой он не появится.
3. `git remote -v` - показать список удалённых репозиториев с похожим содержимым. Смотрим на `git status` - ahead of master.
4. Делаем `git push origin master` - запушить ветку такую-то и все её коммиты в `origin`.
5. Проверяем - ура, появилось!

Ситуация:

1. Сделали коммит в старом.
2. В новом не появился. `git pull` и успех!

Теперь ситуация: кто-то взял и сделал там изменение.

1. Делаем коммит в старом.
2. Делаем коммит в новом.
3. Делаем `push` в новом. Упс.
4. `git log --all --graph --oneline --decorate`, видим `origin/master` - это _локальная копия удалённой ветки_. Разошлось понимание, поэтому push отвергается.
5. Что делать:
	1. `git pull`. Сделает merge, получим лишний коммит, но работает. Ну и merge conflict можем получить.
	2. Обычно работает `git pull --rebase`. Вытягивает изменения и пытается применить наши изменения к удалённой ветке. Если получилось - успех. Если не получилось - merge conflict, править руками, можно в любой момент сделать `git merge --abort`.
	3. Намёк: можно создать точку в старом месте, `git fetch` (только поменяет `origin/master`), перенести ветку на `origin/master` и сделать то же самое руками. Или при помощи `merge`.

Правило: никогда не переписывать историю, которую вы уже кому-то отдали. НИКОГДА. Иначе он будет постоянно натыкаться на вот такой вот конфликт. Или хуже - он может свои изменения уже сделать поверх ваших и ему придётся переделывать.
А вот при обычном `git pull` происходит так называемый "fast-forward merge", с ним всё ок.

Вот почему важно делать корректные коммиты: чтобы у других было поменьше проблем. А если только вы работаете - вырабатывайте хорошую привычку. Сообщения к коммитам тоже хорошо бы содержательные, чтобы вы могли найти "а как вы там пофиксили такое-то замечание". Например, на мои письма я бы отвечал в несколько коммитов: сначала стиль, а потом по коммиту на содержательное замечание. Тогда всегда можно откатиться обратно и сохранить хотя бы стилистические изменения.
