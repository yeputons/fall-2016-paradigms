\documentclass[utf8,xcolor=table]{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{minted}
\usepackage{ulem}
\usepackage{cmap}

\mode<presentation>{
	\usetheme{CambridgeUS}
}

\renewcommand{\t}[1]{\ifmmode{\mathtt{#1}}\else{\texttt{#1}}\fi}

\title{Продолжаем классы}
\author{Егор Суворов}
\institute[СПб АУ]{Курс <<Парадигмы и языки программирования>>, подгруппа 3}
\date[28.09.2016]{Среда, 28 сентября 2016 года}

\setlength{\arrayrulewidth}{1pt}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[t]{Где использовать классы}
	Инвариант "--- свойство, которое должно всегда выполняться.

	Мнемоническое правило для некоторых случаев:
	если некоторые переменные удовлетворяют свойствам ниже, то перед вами наверняка объект.
	\begin{itemize}
		\item
			\textit{Логически относятся к одной сущности}: если хранятся в разных массивах, то всегда с одинаковым индексом.
		\item
			\textit{Связаны инвариантом}: если меняется одно свойство, то другое может стать некорректным.
		\item 
			\textit{Требуют обработки вместе}: нет разумных функций, принимающий только одну переменную из группы.
	\end{itemize}
\end{frame}

\begin{frame}[t]{Где ещё использовать классы}
	В так называемых \textit{паттернах} (будут потом в курсе).
	Удобно использовать для описания небольших самостоятельных кусочков программы, из которых можно что-то собирать.
	Например:
	\begin{itemize}
		\item Команды или операции, которые можно применить или отменить.
		\item Обработчки событий, которые могут реагировать на событие по-разному:
			\begin{itemize}
				\item Проигнорировать.
				\item Передать другому обработчику.
				\item Записать в лог.
			\end{itemize}
		\item Физические объекты: кнопки на экране (реагируют на нажатия, находятся в определённой точке экрана), игроки, окна на экране (содержат кнопки).
	\end{itemize}
\end{frame}

\begin{frame}[t]{Это всего лишь парадигма!}
	Здесь идея <<объектов>> позволяет абстрагироваться от деталей реализации, причём с большей мощью, чем простые функции.

	\begin{center}
		Объекты и классы "--- это просто \textbf{ещё один способ структуризации}!
	\end{center}

	Можно переписать любой код в объектно-ориентированном стиле без объектов вообще.
\end{frame}

\begin{frame}[t]{Наследование}
	\begin{itemize}
		\item
			Иногда классы имеют общую (или похожую) функциональность.
			Например, кнопки и текстовые поля в окошке: прямоугольники, знают свой размер, могут себя нарисовать.
		\item
			Хранить общий код можно в функциях.
			Но с данными так не получится.
		\item
			Более изящное решение: наследование.
			Заводим общего предка (суперкласс) с общим кодом.
		\item
			Подклассы могут переопределять поведение суперкласса или расширять его.
	\end{itemize}

	\textbf{Принцип подстановки Барбары Лисков:} если где-то использовался суперкласс, то в том же месте
	можно без изменений безболезненно использовать и любой подкласс.
\end{frame}

\begin{frame}[t]{Пример-1}
	Суперкласс (родитель): <<объект в окне приложения>>:
	\begin{itemize}
		\item \t{width()}/\t{height()}
		\item \t{try\_change\_size(new\_width, new\_height) -> bool}
		\item \t{paint()}
	\end{itemize}

	Подклассы:
	\begin{itemize}
		\item
			\textit{Кнопка без надписи}: рисует бордюр по периметру, реагирует на нажатия кнопки.
		\item
			\textit{Текстовое поле}: не позволяет сильно уменьшить высоту.
	\end{itemize}

	Пример нарушения принципа: мы требуем вызывать метод \t{prepare\_paint()} перед каждым \t{paint()}.

	Иногда вместо наследования лучше подходит композиция (один объект хранится как поле другого).
	Например, если объекты сильно разные или если происходит нарушение принципа.
\end{frame}

\begin{frame}[t]{Пример-2}
	Суперкласс: <<банковский аккаунт>>:
	\begin{itemize}
		\item \t{balance()}
		\item \t{withdraw(amount)}
		\item \t{deposit(amount)}
	\end{itemize}
	\pause

	Подкласс: <<дебетовый счёт>>, не разрешает уходить в отрицательный баланс.

	Есть ли проблемы?
	\pause

	Зависит от формулировки:
	\begin{enumerate}
		\item Если суперкласс гарантировал, что всегда можно снять деньги, то нарушается принцип Лисков.
		\item Если суперкласс не давал никаких гарантий про операции, то проблем нет.
	\end{enumerate}
\end{frame}

\begin{frame}[t]{Пара слов про интерфейсы}
	Суперкласс в примере с банком "--- это не столько <<общие функции>>, сколько
	<<общий интерфейс>> с какой-то реализацией.
	Соглашения обычно просто пишутся в комментариях.
	\\

	Также есть чистые интерфейсы, в которых запрещены реализации.
	А зачем? \pause
	Чтобы нельзя было забыть что-то реализовать и остаться со странной реализацией <<по умолчанию>>.
	\\

	В статически типизированных языках чистые интерфейсы полезны.
	В Python есть утиная типизация и они полезны разве что для программистов, читающих код.
	\\

	\pause
	Есть ли теперь проблемы?
	\pause
	Да: всё ещё нет гарантий, что мы что-то забыли, но теперь программа просто упадёт.
\end{frame}

\begin{frame}[t,fragile]{Наследование в Python}
\begin{minted}{python}
class A:
    def __init__(self, foo):
        self.foo = foo
    def inc_foo(self):
        self.foo += 1
    def __str__(self):
        return "A({})".format(self.foo)

class B(A):
    # __init__ is not overwritten
    def inc_foo(self):  # override
        self.foo += 2  # problem?
    def __str__(self):  # override
        return "B({})".format(super(B, self).__str__())
\end{minted}
\end{frame}

\begin{frame}[t]{Что произошло}
	\begin{itemize}
		\item Класс \t{B} "--- наследник класса \t{A}.
		\item Конструктор остался старый.
		\item Методы \t{inc\_foo} и \t{\_\_str\_\_} мы \textit{перезаписали}
		\item В методе \t{\_\_str\_\_} вызываем старую реализацию.
		\pause
		\item Метод \t{inc\_foo} нарушил принцип подстановки Лисков.
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Стреляем себе в ногу}
	Python "--- язык динамический.
	Смотрим демонстрацию.
	\pause

	Процесс поиска метода/переменной \t{x.foo}:
	\begin{itemize}
		\item
			В самом объекте \t{x}: \t{x.foo}
		\item
			В классе объекта \t{x}: \t{type(x).foo}
		\item
			Во всех предках класса \t{x}.
	\end{itemize}
\end{frame}

\begin{frame}[t]{Прочие плюшки}
	\begin{itemize}
		\item \t{Class.\_\_name\_\_}
		\item \t{x.\_\_dict\_\_} или \t{vars(x)}
		\item \t{type(x)}
		\item \t{isinstance(x, A)}
		\item \t{issubclass(A, B)}
		\item Есть множественное наследование.
		\item Есть даже ромбовидное наследование.
		\item При множественном наследовании есть специальный алгоритм <<линеаризации>>, которые упорядочивает всех предков для поиска функций.
	\end{itemize}
\end{frame}

\end{document}
