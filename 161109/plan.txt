== Алгебраические типы данных ==

=== Тип-сумма ===
struct - это тип-произведение, составной тип, есть много где.
Пример: способ оплаты: карта онлайн, наличка, QIWI.
На C/C++ можно было бы сделать struct {флаги; значения}, но тогда мы можем случайно получить доступ к значению, которое не имеет смысла, получить неконсистентное состояние (один ребёнок, а не 0/2), жрём память почём зря.
Ещё можно enum.
В ООП можно эмулировать через общий интерфейс и кучу наследников, и проверять тип динамически.
Придётся либо dynamic_cast (тогда компилятор не проверит, что всё разобрано), либо городить Visitor'ы.

Тип-сумма - вмонтировали такую хрень в язык.
Показать pattern matching на примере способа оплаты и to_string, намекнуть про deriving Show.
Пример: getItem :: [Char] -> Int -> CharOrNotFound.
Обновить CharOrNotFound до параметризованного GetResult a, показать Maybe.

Ещё примеры: Either значение ошибка, просто куча, типобезопасная min-max куча, AST-дерево выражения, односвязные списки.
Показать, что Pattern Matching может идти внутрь, показать оптимизатор для выражений на ЯТЬ.
Упражнение на бесконечные деревья.

Резюме:
Бонус поддержки уровня языка: вмонтировано в pattern matching, не надо городить Visitor'ов, компилятор проверяет, что все случаи разобраны.
Очень популярно в AST в компиляторах: бинарное выражение, программа.

=== Возвращаемся к алгебре ===
Любой тип - это тип-сумма (в том числе Int).
Есть типы высшего порядка вроде Maybe.

Можно считать количество значений типа, тогда натуральным образом получатся произведения, суммы, дистрибутивность.

=== Этимология ===
Алгебра - множество A, на котором есть сколько-то операций произвольной арности. Свойств нет.

Алгебраический тип - тип, который получен из более простых типов некоторыми операциями.
Например, struct. Зовётся тип-произведение.
Получили алгебру типов из примитивных типов и типов-произведений.
Пока что ничего нового.

=== Пример ===
Есть архиватор, который умеет паковать/распаковать один файл, есть параметры: входной файл, выходной файл, операция. Как закодировать это типом?
А теперь добавили пароль, он нужен в две стороны.
А теперь добавили параметры: "уровень логирования", "язык компилятора", "взять только байты с такого по такой", "не перезаписывать файл при существовании"
А теперь добавили такие параметры: "формат архива", "степень сжатия", "дописать в конец архива".
Добавлять Maybe тут плохо, лучше разделить параметры на "общие" и "специфичные", и сделать отдельный тип.

=== Пример ===
Надо закодировать URL: <схема-хвост>/<путь>. Потом <схема-хвост>=[<схема>://]<хост>
А потом <схема-хвост> может отсутствовать.
А может быть как относительным, так и абсолютным.
Получили (Maybe (Maybe (String, String)), String), что-то жесть (идея такая: если схема-хвост указаны, но неизвестны, то путь абсолютный, иначе относительный).
По-хорошем стоит сделать Absolute, Relative, и так далее.

=== Пример ===
data Length в разных единицах - не запутаемся.
Можно обработать один случай, а для остальных вызвать Convert. Или сделать where/let и вызвать convert сразу.

=== Резюме ===
Полезно в некоторых случаях: когда у нас значений мало, но их надо постоянно обрабатывать.
Visitor'ы и ООП делают скос в другую сторну: сценариев немного, но значения постоянно добавляются.
Свои специализированные типы - это круто, позволяют компилятору проверять больше.

== Классы типов ==
=== Перегрузка методов ===
Написали свой список int'ов, попробовали сравнить, не получилось. Добавили deriving Eq - получилось. Магия.
Pattern Matching-то работал? Просто == - это функция, а не конструкция языка.
На самом деле Eq - это такой интерфейс.
В C++/Java мы бы написали перегрузку функции.
Показать :t lookup
Реализации по умолчанию.
Классы для параметризованных типов: Eq дли списков, Mappable/Functor.

Можно завести свой интерфейс и сделать, чтобы его реализовывал любой тип (пример с HasSize).
Фиг такое сделаем в плюсах или Java - там типы закрыты.

Можно писать deriving для некоторых стандартных классов.
Ещё есть классы Functor, Foldable.

Можно определить Ord отдельно от Eq (тогда везде таскать и получается, что они не связаны, хотя есть антисимметричность),
можно скопипастить (тогда в чём проблема? Не получится преобразовать, надо везде таскать), можно прямо отнаследовать в class where,
тогда будет таскаться неявно.

Показать автовывод типов.

Чем перегрузка хороша: работает. Чем перегрузка плоха: не отражает связи между функциями (== и /=),
не требует реализовывать всё нужное (можно написать только == и забыть, пока не потребуется).
А если оставляем только интерфейсы и запрещаем функции с одинаковыми именами, то компилятор автоматически выводит нужные интерфейсы всем аргументам, круто.
На самом деле, мы их запрещаем одинаковые имена только пока путаницы не возникает, то если если не используем - то норм.

Упражнение "вот дерево и Reversable, добавьте instance".

=== Бонус ===
Инфиксные конструкторы данных.
Каррирование.
Как сделать ввод-вывод в чисто функциональных языках (RealWorld).
Как сделать ввод-вывод в Haskell (IO, которая всё засоряет и как с ней бороться).
