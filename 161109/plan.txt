== Алгебраические типы данных ==
=== Этимология ===
Алгебра - множество A, на котором есть сколько-то операций произвольной арности. Свойств нет.

Алгебраический тип - тип, который получен из более простых типов некоторыми операциями.
Например, struct. Зовётся тип-произведение.
Получили алгебру типов из примитивных типов и типов-произведений.
Пока что ничего нового.

=== Тип-сумма ===
Пример: способ оплаты: карта онлайн, наличка, QIWI.
На C/C++ можно было бы сделать struct {флаги; значения}, но тогда мы можем случайно получить доступ к значению, которое не имеет смысла, получить неконсистентное состояние (один ребёнок, а не 0/2), жрём память почём зря.
Ещё можно enum.
В ООП можно эмулировать через общий интерфейс и кучу наследников, и проверять тип динамически.
Придётся либо dynamic_cast (тогда компилятор не проверит, что всё разобрано), либо городить Visitor'ы.

Тип-сумма - вмонтировали такую хрень в язык.
Показать pattern matching на примере способа оплаты и to_string, намекнуть про deriving Show.
Пример: getItem :: [Char] -> Int -> CharOrNotFound.
Обновить CharOrNotFound до параметризованного GetResult a, показать Maybe.

Ещё примеры: Either значение ошибка, просто куча, типобезопасная min-max куча, AST-дерево выражения, односвязные списки.
Показать, что Pattern Matching может идти внутрь, показать оптимизатор для выражений на ЯТЬ.

Резюме:
Бонус поддержки уровня языка: вмонтировано в pattern matching, не надо городить Visitor'ов, компилятор проверяет, что все случаи разобраны.
Очень популярно в AST в компиляторах: бинарное выражение, программа.

=== Возвращаемся к алгебре ===
На самом деле enum - это тоже тип-сумма единичных типов.
Показать, какие алгебраические операции происходят тут:
data Bool = False | True
data Int = 1 | 2 | 3 | ...
data DayOfWeek = Monday | Tuesday | ...
А тут получаются не совсем типы, а мы создаём "типы высшего порядка"
data Maybe a = Nothing | Just a
data List a = Empty | a :++ List a
data Either a b = Left a | Right b
Показать deriving Show, Eq (сказать, что скоро разберёмся)

Можно считать количество элементов, есть дистрибутивность. Но она же есть и на обычных типах!
На самом деле, можно ввести даже возведение в степень (функции, неважно), и даже производные (в 2001 году обнаружили смысл).

=== Пример ===
Есть архиватор, который умеет паковать/распаковать один файл, есть параметры: входной файл, выходной файл, операция. Как закодировать это типом?
А теперь добавили пароль, он нужен в две стороны.
А теперь добавили параметры: "уровень логирования", "язык компилятора", "взять только байты с такого по такой", "не перезаписывать файл при существовании"
А теперь добавили такие параметры: "формат архива", "степень сжатия", "дописать в конец архива".
Добавлять Maybe тут плохо, лучше разделить параметры на "общие" и "специфичные", и сделать отдельный тип.

=== Пример ===
Надо закодировать URL: <схема-хвост>/<путь>. Потом <схема-хвост>=[<схема>://]<хост>
А потом <схема-хвост> может отсутствовать.
А может быть как относительным, так и абсолютным.
Получили (Maybe (Maybe (String, String)), String), что-то жесть (идея такая: если схема-хвост указаны, но неизвестны, то путь абсолютный, иначе относительный).
По-хорошем стоит сделать Absolute, Relative, и так далее.

=== Пример ===
data Length в разных единицах - не запутаемся.
Можно обработать один случай, а для остальных вызвать Convert. Или сделать where/let и вызвать convert сразу.

=== Резюме ===
Полезно в некоторых случаях: когда у нас значений мало, но их надо постоянно обрабатывать.
Visitor'ы и ООП делают скос в другую сторну: сценариев немного, но значения постоянно добавляются.
Свои специализированные типы - это круто, позволяют компилятору проверять больше.

== Классы типов ==
=== Перегрузка методов ===
Написали свой список int'ов, попробовали сравнить, не получилось. Добавили deriving Eq - получилось. Магия.
Pattern Matching-то работал? Просто == - это функция, а не конструкция языка.
На самом деле Eq - это такой интерфейс. Можно написать руками, но компилятор сам тоже справляется.
В C++/Java мы бы написали перегрузку функции.
Чем перегрузка хороша: работает. Чем перегрузка плоха: не отражает связи между функциями (== и /=),
не требует реализовывать всё нужное (можно написать только == и забыть, пока не потребуется).
В Java могли бы написать интерфейс "Comparable", получилось бы всё круто.
А если оставляем только интерфейсы и запрещаем функции с одинаковыми именами, то компилятор автоматически выводит нужные интерфейсы всем аргументам, круто.
На самом деле, мы их запрещаем одинаковые имена только пока путаницы не возникает, то если если не используем - то норм.

=== Свои интерфейсы на чужих типах ===
Можно завести свой интерфейс и сделать, чтобы его реализовывал любой тип (пример с HasSize).
Также можно добавить реализации по умолчанию (пример с == и /=).
Также можно сделать автовывод интерфейса из других, но этим мы заниматься не будем - там возникают небольшие сложности с тем, что компилятор хочет очень строгих гарантий про систему типов.
Фиг такое сделаем в плюсах или Java - там типы закрыты.

=== Eq => Ord, наследование ===
Можно определить Ord отдельно от Eq (тогда везде таскать и получается, что они не связаны, хотя есть антисимметричность),
можно скопипастить (тогда в чём проблема? Не получится преобразовать, надо везде таскать), можно прямо отнаследовать в class where,
тогда будет таскаться неявно.

=== Бонус ===
Ещё можно делать классы типов для параметризованных типов.
Например, Functor и Foldable - им удовлетворяют списки.
Инфиксные конструкторы данных.
Каррирование.
Как сделать ввод-вывод в чисто функциональных языках (RealWorld).
Как сделать ввод-вывод в Haskell (IO, которая всё засоряет и как с ней бороться).
