\documentclass[utf8,xcolor=table]{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{minted}
\usepackage{ulem}

\hypersetup{colorlinks,linkcolor=blue,urlcolor=blue}

\mode<presentation>{
	\usetheme{CambridgeUS}
}

\renewcommand{\t}[1]{\ifmmode{\mathtt{#1}}\else{\texttt{#1}}\fi}

\title{Операторы, метаклассы, паттерны}
\author{Егор Суворов}
\institute[СПб АУ]{Курс <<Парадигмы и языки программирования>>, подгруппа 3}
\date[05.10.2016]{Среда, 5 октября 2016 года}

\setlength{\arrayrulewidth}{1pt}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{План занятия}
	\tableofcontents
\end{frame}

\section{Перегрузка операторов}
\subsection{Мотивация}

\begin{frame}
	\tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]{Зачем перегружать?}
	\begin{itemize}
		\item Задание требуемой семантики у своих объектов:	
\begin{minted}{python}
class Foo:
    def __init__(self, value):
        self.value = value
Foo("hello") == Foo("hello")  # False
\end{minted}

		\item Упрощение кода с математическими объектами:
\begin{minted}{python}
# До
res = a.multiply(x).add(b.multiply(y)) \
    .add(c).multiply(5).add(2)
middle = vector1.add(vector2).multiply(0.5)
	
# После
res = (a * x + b * y + c) * 5 + 2
middle = (vector1 + vector2) / 2
\end{minted}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Почему не перегружать?}
	\pause
	\begin{itemize}
		\item
			Разное поведение у похожих типов.
			Например: определим \t{/} как целочисленное деление.
			Лучше определить только \t{//}.
			\pause
		\item
\begin{minted}{cpp}
line a = /* ... */, b = /* ... */;
if (a || b) { /* ... */ }
\end{minted}
			\pause
			Можно сказать, что \t{||} возвращает, параллельны ли прямые.
			Полностью изменяется семантика оператора.
			\pause
		\item
			Скрывает сложные операции при чтении кода.
			Может мешать при отладке и поиске медленных мест "--- нет явного вызова функции:
\begin{minted}{python}
a = 10 ** 10000
b = 10 ** 10000
# ...
result = a * b  # Почему же тормозит?
\end{minted}
		\item
			Неочевидное поведение: \t{vec1 * vec2}.
			\pause
			Векторное или скалярное произведение?
	\end{itemize}
\end{frame}

\subsection{Немного магии}
\begin{frame}{Магические методы}
	\begin{itemize}
		\item
			\textit{Магическим} зовётся метод, название которого начинается и заканчивается на \t{\_\_}.
			Например, \t{\_\_init\_\_} или \t{\_\_str\_\_}.
		\item Ничего магического, кроме предназначения, в них нет.
		\item Напрямую их вызывать не стоит!
		\item Перечислены в документации по группам. Объекты могут прикидываться:
			\begin{enumerate}
				\item \href{https://docs.python.org/3/reference/datamodel.html\#emulating-numeric-types}{Числами}.
				\item \href{https://docs.python.org/3/reference/datamodel.html\#object.\_\_lt\_\_}{Чем-то, что можно сравнивать}.
				\item \href{https://docs.python.org/3/reference/datamodel.html\#emulating-callable-objects}{Функциями}.
				\item \href{https://docs.python.org/3/reference/datamodel.html\#emulating-container-types}{Коллекциями} (массив, словарь, множество...).
				\item \href{https://docs.python.org/3/library/stdtypes.html\#typeiter}{Итераторами} (обслуживают цикл \t{for}).
				\item \href{https://docs.python.org/3/reference/datamodel.html\#with-statement-context-managers}{Чем-что, что можно автоматически закрывать} (файл, сетевое соединение).
				\item И ещё много чем.
			\end{enumerate}
		\item Что-то есть \href{https://pythonworld.ru/osnovy/peregruzka-operatorov.html}{на русском}.
	\end{itemize}
\end{frame}

\subsection{Синтаксис арифметики}

\begin{frame}[fragile]{Как перегружать}
\begin{minted}{python}
class Natural:
    def __init__(self, value):
        assert value >= 1
        self.value = value
    def __add__(self, other):
        return Natural(self.value + other.value)
    def __sub__(self, other):
        return Natural(self.value - other.value)
    def  __repr__(self):  # Почти __str__
        return "Natural({})".format(self.value)
print(Natural(4) + Natural(3))  # 7
print(Natural(4) - Natural(3))  # 1
print(Natural(4) - Natural(4))  # AssertionError
print(Natural(4).__sub__(Natural(3)))  # Не надо так!
\end{minted}
\end{frame}

\begin{frame}[fragile]{Разные типы-1}
\begin{minted}{python}
print(Natural(4) + 3)           # AttributeError
def better_add(self, other):
    if isinstance(other, Natural):
        return Natural(self.value + other.value)
    elif isinstance(other, int):
        return Natural(self.value + other)
    else:
        return NotImplemented
Natural.__add__ = better_add

print(Natural(4) + Natural(3))  # 7
print(Natural(4) + 3)           # 7
print(Natural(4) + "3")         # TypeError
print(3 + Natural(4))           # TypeError?
\end{minted}
\end{frame}

\begin{frame}[fragile]{Разные типы-2}
\begin{minted}{python}
print(3 + Natural(4))  # У int нет метода __add__ для Natural
int.__add__ = None     # И задать часто нельзя. И не надо.
Natural.__radd__ = Natural.__add__

print(Natural(4) + 3)           # 7
print(3 + Natural(4))           # 7
\end{minted}

	При вычислении выражения \t{a + b}:
	\begin{enumerate}
		\item Вызывается \t{a.\_\_add\_\_(b)}.
		\item Если метод найден и не вернули \t{NotImplemented} "--- успех.
		\item Иначе, если \t{a} и \t{b} разных типов, вызывается \t{b.\_\_radd\_\_(a)}.
		\item Если не помогло "--- неуспех.
	\end{enumerate}

	Также есть методы \t{\_\_rsub\_\_}, \t{\_\_rmul\_\_} и другие.
\end{frame}

\begin{frame}[fragile]{Разные типы-3}
\begin{minted}{python}
class Foo:
    def __add__(self, other):
        print("add")
        return NotImplemented
    def __radd__(self, other):
        print("radd")
        return self

print(Natural(3) + Foo())  # radd
print(Foo() + Natural(3))  # add, TypeError
\end{minted}
\end{frame}

\subsection{Синтаксис сравнений}
\begin{frame}[fragile]{Сравнения-1}
\begin{minted}{python}
class Natural:
    def __init__(self, value):
        self.value = value
    def __lt__(self, other):  # Less than
        return self.value < other.value
    def __le__(self, other):  # Less or equal
        return self.value <= other.value
    def __eq__(self, other):
        return self.value == other.value
ONE, TWO = map(Natural, [1,2])
print(ONE < TWO, ONE > TWO)    # True False
print(ONE <= TWO, ONE >= TWO)  # True False
print(ONE == TWO, ONE != TWO)  # False True
print(ONE == ONE, ONE != ONE)  # True False
\end{minted}
\end{frame}

\begin{frame}[fragile]{Сравнения-2}
	\begin{itemize}
		\item
			Оператор \t{\_\_lt\_\_} и \t{\_\_gt\_\_} считаются отражениями друг друга.
			Почти как \t{\_\_add\_\_} и \t{\_\_radd\_\_}.
		\item
			Оператор \t{\_\_ne\_\_} по умолчанию берёт отрицание от \t{\_\_eq\_\_}.
		\item
			Оператор \t{\_\_lt\_\_} автоматически из \t{\_\_le\_\_} и \t{\_\_eq\_\_} не выводится.
	\end{itemize}
	Можно использовать \textit{декоратор} \href{https://docs.python.org/3/library/functools.html\#functools.total\_ordering}{\t{total\_ordering}}:
\begin{minted}{python}
from functools import total_ordering
@total_ordering  # Магия.
class Natural:
    # Надо задать метод __eq__ и один из четырёх сравнивающих.
    #
    # Остальное сгенерируется.
\end{minted}
\end{frame}

\begin{frame}[fragile]{Хэш-таблицы-1}
\begin{minted}{python}
a = { Natural(1): 1 }  # TypeError: unhashable type

class Natural:
    def __init__(self, value):
        self.value = value
    def __eq__(self, other):
        return self.value == other.value
    def __hash__(self):
        return hash(self.value)
    def __repr__(self):
        return "Natural({})".format(self.value)

a = {Natural(x): x for x in range(5)}
print(a)
\end{minted}
\end{frame}

\begin{frame}{Хэш-таблицы-2}
	\begin{itemize}
		\item
			\t{\_\_hash\_\_} вызывается функцией \t{hash}, когда элемент кладут в хэш-таблицу.
			Должна вернуть \t{int}.
		\item
			Требование: если \t{a == b}, то \t{hash(a) == hash(b)} (в обратную сторону необязательно).
		\item
			Если определён \t{\_\_hash\_\_}, то обязательно определить \t{\_\_eq\_\_}.
		\item
			Для помещения в хэш-таблицу методы \t{\_\_lt\_\_} необязательны.
		\item
			В языке Java идеология похожа: методы \t{equals()} и \t{hashCode()}.
		\item
			Если объект может измениться (\textit{мутабельный}), то \t{\_\_hash\_\_} определять не стоит.
			Почему?
			\pause
			Потому что если он изменится, пока лежит в хэш-таблице, она об этом не узнает и сломается.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Хэш-таблицы-3}
	Чем плоха реализация строки ниже?
\begin{minted}{python}
class Str:
    def __init__(self, value): self.value = value
    def __eq__(self, other): return self.value == other.value
    def __hash__(self):
        result = 0
        for c in self.value:
            result = result * 239017 + ord(c)
        return result
\end{minted}
	\pause
\begin{minted}{python}
print(hash("a" * 1000))
print(hash(Str("a" * 1000)))
print(hash("a" * 100000))
print(hash(Str("a" * 100000)))
\end{minted}
	\pause
	Тормозит, потому что в Python \t{int} автоматически преобразуется в длинную арифметику,
	а не переполняется.
\end{frame}

\subsection{Наследование}

\begin{frame}[fragile]{Беда?}
\begin{minted}{python}
class Point:
    def __init__(self, x, y): self.x, self.y = x, y
    def __eq__(self, other):
        return (self.x, self.y) == (other.x, other.y)
class PointWithId(Point):
    def __init__(self, x, y, id):
        super(PointWithId, self).__init__(x, y)
        self.id = id
    def __eq__(self, other):  # Принцип Лисков?
        return ((self.x, self.y, self.id) ==
                (other.x, other.y, other.id))
base, child = Point(1, 2), PointWithId(1, 2, 3)
print(base.__eq__(child))            # True
print(child.__eq__(base))            # AttributeError
print(base == child, child == base)  # ???
\end{minted}
\end{frame}

\begin{frame}[t]{Беда!}
	Неясно, как сравнивать объекты разных типов на равенство в общем случае:
	\begin{enumerate}
		\item Можно запретить сравнение объектов разных типов, но нарушится
			\only<-1>{???}\only<2->{принцип подстановки.}
		\item Можно сравнивать только по общим полям, но тогда нарушится
			\only<-2>{???}
			\only<3->{
			транзитивность:
			\[(child_1 = base) \land (base = child_2) \not\Rightarrow child_1=child_2\]
			}
	\end{enumerate}
	\only<4->{
	В любом случае, суперкласс ничего про детей не знает, поэтому вызывать его метод скорее бессмысленно.
	Python всегда вызовет метод подкласса (будь то \t{\_\_eq\_\_}, \t{\_\_le\_\_} или \t{\_\_ge\_\_}).

	В других языках может быть по-другому!
	Надёжнее всего считать объекты разных типов разными.
	}
\end{frame}

\begin{frame}{Вообще беда}
	С сортировкой ещё хуже.
	Надо определить какой-то линейный порядок на всех объектах:
	не только транзитивность, но ещё и согласованность с равенством, например:
	\[ a \neq b \iff (a < b) \lor (a > b) \]

	Как разрулить в общем случае?
	\pause
	Запретить сравнивать объекты разных типов!

	Как тогда не нарушить принцип подстановки?
	\pause
	Запретить сравнивать объекты типа <<суперкласс>>, если только не известно заведомо, что они одного типа.
\end{frame}

\subsection{Притворяемся функцией}

\begin{frame}[fragile]{Притворяемся функцией}
\begin{minted}{python}
class Summer:  # Сумма, а не лето :(
    def __init__(self, k):
        self.k = k
    def __call__(self, *args):
        return self.k * sum(args)
s = Summer(3)
print(s())       # 0
print(s(1))      # 3
print(s(1, 10))  # 33
\end{minted}
	Всё, что имеет метод \t{\_\_call\_\_}, может быть вызвано.
	И наоборот:
\begin{minted}{python}
def foo(): print("foo")
print(foo.__call__)
foo.__call__()
print(foo.__call__.__call__)
\end{minted}
\end{frame}

\begin{frame}{Но зачем?}
	\begin{itemize}
		\item
			Объект каком-то смысле представляет собой функцию.
			Например: <<преобразование плоскости>>, <<логгер>> или <<выражение от одной переменной>>.
		\item
			В некоторых других языках это единственный способ сделать функцию с некоторым внутренним состоянием (кроме глобальных переменных).
		\item
			Все проблемы с перегрузкой операторов остаются.
			Не злоупотребляйте!
	\end{itemize}
\end{frame}

\section{Притворяемся коллекцией}

\subsection{Словарь}
\begin{frame}[fragile]{Словарь}
\begin{minted}{python}
class KeyToPrependedKey:
    def __init__(self, prefix):
        self.prefix = prefix
    def __getitem__(self, name):
        return self.prefix + name
a = KeyToPrependedKey("foo_")
print(a["bar"])  # foo_bar
\end{minted}
	Ещё бывают методы \t{\_\_setitem\_\_}, \t{\_\_delitem\_\_}, \t{\_\_len\_\_}, \t{\_\_contains\_\_}, \t{\_\_reversed\_\_}, \t{\_\_missing\_\_}, \t{\_\_iter\_\_} (см. дальше).
\end{frame}

\begin{frame}[fragile]{Массив со срезами}
	Срезы передаются просто как объект типа \t{slice}:
\begin{minted}{python}
class RangeMeasurer:
    def __getitem__(self, s):
        if isinstance(s, slice):
            return s.stop - s.start
        else:
            return 1
print(RangeMeasurer()[2:4])    # 2
print(RangeMeasurer()[4:2])    # -2
print(RangeMeasurer()[2:4:2])  # 2
print(RangeMeasurer()[:2])     # ???
print(RangeMeasurer()[2:])     # ???
\end{minted}
	\pause
	Все случаи надо либо разбирать руками, либо использовать функцию \t{slice.range()}.
\end{frame}

\subsection{Итераторы}
\begin{frame}[fragile]{Пример итератора}
\begin{minted}{python}
class CountDownIterator:
    def __init__(self, start): self.value = start
    def __iter__(self):
        return self  # Так надо.
    def __next__(self):
        if self.value < 1:
            raise StopIteration
        self.value -= 1
        return self.value + 1
v = CountDownIterator(5)
print(v)
print(v.__next__())  # 5
print(v.__next__())  # 4
\end{minted}
\end{frame}

\begin{frame}[fragile]{Коллекции и итераторы}
	Всё, у чего есть метод \t{\_\_iter\_\_}, можно запихнуть в цикл \t{for} и другие интересные места:
\begin{minted}{python}
a = [1,2,3]
print([ x for x in a ])
it = a.__iter__()
print(it.__next__()) # 1
print(it.__next__()) # 2
print(it.__next__()) # 3
print(it.__next__()) # StopIteration

a = CountDownIterator(5)
print(list(a))  # 5 4 3 2 1
print(list(a))  # ???
\end{minted}
\end{frame}

\begin{frame}{Что произошло}
	\begin{itemize}
		\item Если коллекция закончилась, итератор должен вызвать \t{raise StopIteration}.
		\item Итератор "--- штука одноразовая, переиспользовать нельзя.
		\item Метод \t{\_\_iter\_\_} у коллекций возвращает \textbf{новый} итератор, указывающий на начало коллекции.
		\item Метод \t{\_\_iter\_\_} есть у каждого итератора, чтобы их можно было использовать там же, где и коллекции.
		\item В других языках интерфейсы коллекции и итератора разнесены более явно.
	\end{itemize}
\end{frame}

\begin{frame}{Что такое StopIteration}
	\t{StopIteration} "--- это так называемое \textit{исключение}.
	\TODO
\end{frame}

% нельзя перегрузить =, в отличие от других языков. там прокси-объекты, тут местами попрямее, местами покривее.
\end{document}
